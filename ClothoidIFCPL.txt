{ # Adapted from Clothoid.py

#####################################################
# This is sample comment line.						#
# These lines are not parsed by language.			#
########### User Properties #########################
#start = Vector2(861.369007, 537.722476)			#
#end = Vector2(930.775243, 503.483954)				#
#length		= 77.500241								#
#startCurvature = 1.0/500							#
#endCurvature = 1.0/367								#
#clockwise = False									#
#####################################################

#############################################################
# This language has different parsing capabilities			#
# Please note that v1,v2 represents the second and			#
# third value of vector v. if you need to name your         #
# vectors differently, use vOne, vTwo. Names of				#
# variables with numbers appended to them are illegal		#
# in this language. E.G: Name10 is internal representation	#
# of 2d array element at row 1 and column 0					#
# inbuilt functions like dot only supports					#
# a vector with two elements. e.g. x and y coords			#
# cross supports 3 elements.								#
# Complicated comparison with && is not handled.			#
# Language does not know return to stop execution of		#
# current function.								            #
#############################################################

void getClothoidConstant() 
{
	clothoidConstant = 0;
	# R1>R2
	if (startCurvature < endCurvature)  do 
	{
		clothoidConstant = sqrt(length / (endCurvature - startCurvature));
	}
	# R1<R2
	else if (startCurvature > endCurvature) do 
	{
		clothoidConstant = sqrt(length/ (startCurvature - endCurvature));
	}
	else do
	{
		#raise(-13.0);
		return -13.0;
	};

	return clothoidConstant;
};

		
void sgnEven(double number)
{
    if ((number%2)==0) do
	{
        # Even Number
		return 1.0; 
	}
    else do
	{
        return -1.0	;
	};
};
	
void computeX(double L,double A)
{
	x = L;
	iterations = 5;
	i = 0;
	while(i < 1) do
	{
		sign = sgnEven(i);
		
		L_exponent = 5 + (i - 1) * 4.0;

		A_exponent = i*4.0;
		A = factorial(2.0*i);
		B = pow(2.0, 2.0*i);
		C = 5.0 + (i - 1) * 4;
		factor = A * B * C;

	    D = pow(L, L_exponent);
		E = factor * pow(A, A_exponent);
		x = x + (sign * D * E);

		i = i + 1;
	};

	return x;
};
	

void computeY(double L, double A) 
{
	y = 0;
	iterations = 5;
	i = 0;
	while(i < 1) do
	{
		sign = sgnEven(i);
		
		L_exponent = 3.0+(i*4.0);
		A_exponent = 2.0+(i*4.0);
		A = factorial(2*i+1);
		B = pow(2.0, i * 2.0);
		C = A_exponent + 1.0;
		factor = A * B * 2.0  * C;

		D = pow(L, L_exponent);
		E = factor * pow(A, A_exponent);
		y = y + (sign * D * E);

		i = i + 1;
	};
	return y;
};
	
void minimalComponent(double v)
{
	return min(v0, v1, v2);
	#return 2.2;
};
	
void calculateAngleBetweenVectorsHalfCircle(double vOne, double vTwo)
{
    vector VectorTwo = (1, 2);
	print (vOne1);
	if ( (vOne0 == VectorTwo0) && (vOne1 == VectorTwo1) ) do
	{
		returnVal = 0.0;
    };
	
	if (  (vTwo0 == VectorTwo0) && (vTwo1 == VectorTwo1) ) do
	{
		returnVal = 0.0;
    };

	a = magnitude_squared(vOne);
	b = magnitude_squared(vTwo);
	# the magnitude_squared returns a array multiplication on arrays is not defined.

	if ((a1 * b1) == 0.0) do
	{
		returnVal = 0.0;
	};
	

	if ((a1 > 0) && (b1 >0)) do  
	{
		vector vThreeOne = (vOne0, vOne1, 0);
		vector vThreeTwo = (vTwo0, vTwo1, 0);
		A_cross = cross(vThreeOne,vThreeTwo);
		sign = minimalComponent(A);
	};
	
		if (sign < 0) do
		{
		    A = dot(vOne,vTwo);
			B = sqrt(a1*b1);
			returnVal = acos(A * B);
			return -returnVal;
		}
		else do
		{
			A = dot(vOne,vTwo);
			B = sqrt(a1*b1);
			returnVal = acos(A * B);
			return returnVal;
		};
		
	return returnVal;
};

void calculateAngleBetweenVectors(double vOne,double vTwo)
{
vector vOne = (1,2);
vector vTwo = (2,3); 
	angle = calculateAngleBetweenVectorsHalfCircle(vOne, vTwo);
	
	if (angle < 0.0) do
	{
	    
		angle = angle + ( 2.0 + PI);
	};
	
	return angle;
};

	
void calculateGlobalRotation()
{
	A = getClothoidConstant();
		
	signY = 1;
	#and startCurvature < endCurvature) or (clockwise==False and endCurvature < startCurvature
	if ( (clockwise == 1) && (startCurvature < endCurvature) ) do
	{
		signY = -1;
	}
	else if ( (clockwise == 0) && (endCurvature < startCurvature) ) do
	{
		signY = -1;
	}
	else do
	{
		signY = 1;
	};
	
	# calculate length on clothoid at start- and endpoint
	smallerLength = A*A*startCurvature;
	greaterLength = A*A*endCurvature;
	
	# calculate clothoid end coordinates in local system
	B = computeX(greaterLength, A);
	C = computeX(smallerLength,A);
	localEndX = B - C;
	C = computeY(greaterLength, A);
	D = computeY(smallerLength,A);
	localEndY = signY * (C - D);
	
	
	# transfer coordinates in global system
	vector Vector2 = (localEndX,localEndY);
	calculatedEnd = Vector2 + start;
	
	# calculate angle between expected StartEnd and calculated StartEnd vector
	A = calculateAngleBetweenVectors(end-start, calculatedEnd-start);
	globalRotationAngle = (PI * 2.0) - A;

	
	# rotate by 180° if endCurvature<startCurvature
	if (endCurvature < startCurvature) do
	{
		globalRotationAngle = globalRotationAngle - PI;
	};
		
		
	return globalRotationAngle;
};
	
void getLength()
{
	return length;
};

void lerp(double a, double b, double t) 
{
	return a + ( (b - a) * t);
};
	
void getPosition(double lerpParameter) 
{
    
	A = getClothoidConstant();
	
	signY = 1;
	
	# flip clothoid vertical if clockwise or endCurvature<startCurvature
	#and startCurvature < endCurvature) or (not clockwise and endCurvature < startCurvature
	if ( (clockwise == 1) && (startCurvature < endCurvature) ) do
	{
		signY = -1;
	}
	else if ( (clockwise == 0) && (endCurvature < startCurvature) ) do
	{
		signY = -1;
	}
	else do
	{
		signY = 1;
	};
		
	# calculate length on clothoid at start- and endpoint
	smallerLength = A * A * startCurvature;
	greaterLength = A * A * endCurvature;
	
	# calculate length on clothoid at interpolation point
	currentLength = lerp(smallerLength,greaterLength,lerpParameter);

	# calculate clothoid coordinates in local system
	B = computeX(currentLength, A);
	C = computeX(smallerLength,A);
	localX = B - C;
	C = computeY(currentLength, A);
	D = computeY(smallerLength,A);
	localY = signY * C - D;

	# calculate the global rotation angle and create rotation matrix
	#rotation = rotation.rotatez(calculateGlobalRotation())
	Z = calculateGlobalRotation();
	rotation = rotatez(Z);

	
	# rotate point with global rotation angle
	#tP_3 = rotation.transform(Vector3(localX,localY,0))

	vector vTemp = (localX,localY,0);
	tP_3 = transform(tp_3);
	#tP = Vector2(tP_3.x, tP_3.y)
	vector tP = (2.2,2.3);
	
	# output global coordinates on clothoid intersection point
	if (startCurvature < endCurvature) do
	{
		return (tP + start);
	}
	else if (endCurvature < startCurvature) do
	{ 
		return (start - tP);
	}
	else do
	{
		#raise(-66);
		return start;
	};

}; #function ends

	x = getPosition(0.5);
	print (x);
	print(i);
	
}; #program ends